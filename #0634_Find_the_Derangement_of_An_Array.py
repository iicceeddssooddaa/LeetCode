class Solution(object):
    def findDerangement(self, n):
        """
        :type n: int
        :rtype: int
        """
        _list, mod = [1,0], 10**9 + 7
        for i in range(3,n + 1): _list[i%2] = (_list[(i - 1)%2] + _list[(i - 2)%2])*(i - 1) % mod
        return _list[n%2]
-------------------
"""
记长度为n的满足条件的乱排序数为An，长度为n恰有一个数字在自己位置（差一个数满足条件）的乱排序数为Bn
考虑递推：
    1.对于An而言，如果除了最后一个数已经排好，则可以把最后一位和前面任何一个数对调，由于前面的数都不是n，因而换到最后一位满足条件，同样地，n放到前面不破坏条件。这部分为（n - 1)A_{n - 1}
    2.插入n之前，如果刚好只有一位不符合，把那个数换到第n位即可。这里有B_{n - 1}那么多。
    3.上述两种显然不同，考虑到对调n之前的序列，1满足条件，2不满足（且一次对调可以实现），因而为全部情形。
    A_{n} = (n - 1)A_{n - 1} + B_{n - 1}
    
    4.对于Bn而言，每个A_{n - 1}记过的完美序列，只要把n放在最后即可。但这忽略了前面i在i位的这一情形。考虑到循环性，数量都一致，因而Bn = nA_{n - 1}
    
    二阶线性递推由此得出：
    A_{n} = (n - 1)(A_{n - 1} + A_{n - 2})
    A_{1} = 0, A_{2} = 1
"""
